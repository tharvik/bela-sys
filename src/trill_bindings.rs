/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
pub struct I2c__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct I2c {
    pub vtable_: *const I2c__bindgen_vtable,
    pub i2C_bus: ::std::os::raw::c_int,
    pub i2C_address: ::std::os::raw::c_int,
    pub i2C_file: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_I2c() {
    const UNINIT: ::std::mem::MaybeUninit<I2c> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<I2c>(),
        16usize,
        concat!("Size of: ", stringify!(I2c))
    );
    assert_eq!(
        ::std::mem::align_of::<I2c>(),
        4usize,
        concat!("Alignment of ", stringify!(I2c))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2C_bus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2c),
            "::",
            stringify!(i2C_bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2C_address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2c),
            "::",
            stringify!(i2C_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2C_file) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2c),
            "::",
            stringify!(i2C_file)
        )
    );
}
pub type std_string = [u32; 6usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = u32;
pub type std_allocator_difference_type = u32;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_value_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Alloc_value_type = u8;
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u32;
pub type std_vector_difference_type = u32;
pub type std_vector_allocator_type = u8;
#[doc = " \\brief A class to use the Trill family of capacitive sensors.\n http://bela.io/trill\n \\nosubgrouping"]
#[repr(C)]
#[derive(Debug)]
pub struct Trill {
    pub _base: I2c,
    pub mode_: Trill_Mode,
    pub device_type_: Trill_Device,
    pub address: u8,
    pub firmware_version_: u8,
    pub num_touches_: u8,
    pub dataBuffer: [u32; 3usize],
    pub commandSleepTime: u16,
    pub preparedForDataRead_: bool,
    pub numBits: ::std::os::raw::c_uint,
    pub posRescale: f32,
    pub posHRescale: f32,
    pub sizeRescale: f32,
    pub rawRescale: f32,
    pub readErrorOccurred: bool,
    #[doc = " @name RAW, BASELINE or DIFF mode\n When the device is in #RAW, #BASELINE, or #DIFF mode, the\n readings from the individual sensing channels are accessed\n through #rawData.\n @{\n/\n/**\n An array containing the readings from the device's\n channel  when the device is in\n #RAW, #BASELINE or #DIFF mode.\n\n The type of data it contains depend on the device mode:\n - #RAW: the #rawData array contains\n   the raw readings of each individual capacitive sensing\n   channel. This corresponds to `CSD_waSnsResult`.\n - #BASELINE:the #rawData\n   array contains the baseline readings of each individual\n   capacitive sensing channel.\n   This corresponds to `CSD_waSnsBaseline`.\n - #DIFF: the #rawData array\n   contains differential readings between the baseline and\n   the raw reading. This corresponds to `CSD_waSnsDiff`."]
    pub rawData: [u32; 3usize],
}
#[doc = "< Auto mode: the mode is set\nautomatically based on the device type"]
pub const Trill_Mode_AUTO: Trill_Mode = -1;
#[doc = "< Centroid mode: detect discrete touches"]
pub const Trill_Mode_CENTROID: Trill_Mode = 0;
#[doc = "< Raw mode"]
pub const Trill_Mode_RAW: Trill_Mode = 1;
#[doc = "< Baseline mode"]
pub const Trill_Mode_BASELINE: Trill_Mode = 2;
#[doc = "< Differential mode"]
pub const Trill_Mode_DIFF: Trill_Mode = 3;
#[doc = " The acquisition modes that a device can be set to."]
pub type Trill_Mode = ::std::os::raw::c_int;
#[doc = "< No device"]
pub const Trill_Device_NONE: Trill_Device = -1;
#[doc = "< A valid device of unknown type"]
pub const Trill_Device_UNKNOWN: Trill_Device = 0;
#[doc = "< %Trill Bar"]
pub const Trill_Device_BAR: Trill_Device = 1;
#[doc = "< %Trill Square"]
pub const Trill_Device_SQUARE: Trill_Device = 2;
#[doc = "< %Trill Craft"]
pub const Trill_Device_CRAFT: Trill_Device = 3;
#[doc = "< %Trill Ring"]
pub const Trill_Device_RING: Trill_Device = 4;
#[doc = "< %Trill Hex"]
pub const Trill_Device_HEX: Trill_Device = 5;
#[doc = "< %Trill Flex"]
pub const Trill_Device_FLEX: Trill_Device = 6;
#[doc = " The types of Trill devices"]
pub type Trill_Device = ::std::os::raw::c_int;
extern "C" {
    #[doc = " An array containing the valid values for the speed parameter\n in setScanSettings()"]
    #[link_name = "\u{1}_ZN5Trill11speedValuesE"]
    pub static Trill_speedValues: [u8; 4usize];
}
#[doc = " The maximum value for the setPrescaler() method"]
pub const Trill_prescalerMax: u8 = 8;
#[test]
fn bindgen_test_layout_Trill() {
    const UNINIT: ::std::mem::MaybeUninit<Trill> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Trill>(),
        80usize,
        concat!("Size of: ", stringify!(Trill))
    );
    assert_eq!(
        ::std::mem::align_of::<Trill>(),
        4usize,
        concat!("Alignment of ", stringify!(Trill))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(mode_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(device_type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmware_version_) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(firmware_version_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_touches_) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(num_touches_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataBuffer) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(dataBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandSleepTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(commandSleepTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preparedForDataRead_) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(preparedForDataRead_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numBits) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(numBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posRescale) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(posRescale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posHRescale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(posHRescale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeRescale) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(sizeRescale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rawRescale) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(rawRescale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readErrorOccurred) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(readErrorOccurred)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rawData) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Trill),
            "::",
            stringify!(rawData)
        )
    );
}
extern "C" {
    #[doc = " \\copydoc Trill::Trill(unsigned int, Device, uint8_t)\n\n @return 0 upon success, an error code otherwise."]
    #[link_name = "\u{1}_ZN5Trill5setupEjNS_6DeviceEh"]
    pub fn Trill_setup(
        this: *mut Trill,
        i2c_bus: ::std::os::raw::c_uint,
        device: Trill_Device,
        i2c_address: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Probe the bus for a device at the specified address.\n\n @return The type of the device that was found. If no device\n was found, #NONE is returned."]
    #[link_name = "\u{1}_ZN5Trill5probeEjh"]
    pub fn Trill_probe(i2c_bus: ::std::os::raw::c_uint, i2c_address: u8) -> Trill_Device;
}
extern "C" {
    #[doc = " Update the baseline value on the device."]
    #[link_name = "\u{1}_ZN5Trill14updateBaselineEv"]
    pub fn Trill_updateBaseline(this: *mut Trill) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Read data from the device.\n\n Performs an I2C transaction with the device to retrieve new data\n and parse them. Users calling this method won't need to call newData()."]
    #[link_name = "\u{1}_ZN5Trill7readI2CEv"]
    pub fn Trill_readI2C(this: *mut Trill) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set data retrieved from the device.\n\n Sets the data retrieved from the device.\n This can be used to pass to the object\n data retrieved elsewhere (e.g.: from an I2C DMA callback).\n Users calling readI2C() won't need to call this method.\n\n @param newData A pointer to an array containing new data.\n @param len The length of the array."]
    #[link_name = "\u{1}_ZN5Trill7newDataEPKhj"]
    pub fn Trill_newData(this: *mut Trill, newData: *const u8, len: usize);
}
extern "C" {
    #[doc = " \\brief Prepare the device so that successive reads will return data.\n\n This should be called once before trying to read I2C bytes from the\n device via an external method. It is not needed to call this when using\n readI2C()."]
    #[link_name = "\u{1}_ZN5Trill18prepareForDataReadEv"]
    pub fn Trill_prepareForDataRead(this: *mut Trill) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name from the device."]
    #[link_name = "\u{1}_ZN5Trill17getNameFromDeviceB5cxx11ENS_6DeviceE"]
    pub fn Trill_getNameFromDevice(device: Trill_Device) -> *const std_string;
}
extern "C" {
    #[doc = " Get the device from the name."]
    #[link_name = "\u{1}_ZN5Trill17getDeviceFromNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Trill_getDeviceFromName(name: *const std_string) -> Trill_Device;
}
extern "C" {
    #[doc = " Get the mode from the name."]
    #[link_name = "\u{1}_ZN5Trill15getNameFromModeB5cxx11ENS_4ModeE"]
    pub fn Trill_getNameFromMode(mode: Trill_Mode) -> *const std_string;
}
extern "C" {
    #[doc = " Get the mode from the name."]
    #[link_name = "\u{1}_ZN5Trill15getModeFromNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Trill_getModeFromName(name: *const std_string) -> Trill_Mode;
}
extern "C" {
    #[doc = " Print details about the device to standard output"]
    #[link_name = "\u{1}_ZN5Trill12printDetailsEv"]
    pub fn Trill_printDetails(this: *mut Trill);
}
extern "C" {
    #[doc = " Get the number of capacitive channels on the device."]
    #[link_name = "\u{1}_ZN5Trill14getNumChannelsEv"]
    pub fn Trill_getNumChannels(this: *mut Trill) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @name Scan Configuration Settings\n @{\n\n Some of the methods below map directly to function calls and\n variables with the `CSD_` prefix, which are described in the\n [Cypress CapSense Sigma-Delta * Datasheet\n v2.20](https://www.cypress.com/file/124551/download).\n/\n/**\n Set the operational mode of the device.\n\n @param mode The device mode. The special mode #AUTO, selects the\n device-specific default mode for the _detected_ device type.\n @return 0 on success, or an error code otherwise."]
    #[link_name = "\u{1}_ZN5Trill7setModeENS_4ModeE"]
    pub fn Trill_setMode(this: *mut Trill, mode: Trill_Mode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the speed and bit depth of the capacitive scanning.\n This triggers a call to `CSD_SetScanMode(speed, num_bits)`\n on the device.\n\n @param speed The speed of the scanning\n Valid values of speed are, ordered by decreasing speed, are\n comprised between 0 (`CSD_ULTRA_FAST_SPEED`) and 3 (`CSD_SLOW_SPEED`)\n @param num_bits The bit depth of the scanning.\n Valid values are comprised between 9 and 16.\n @return 0 on success, or an error code otherwise."]
    #[link_name = "\u{1}_ZN5Trill15setScanSettingsEhh"]
    pub fn Trill_setScanSettings(
        this: *mut Trill,
        speed: u8,
        num_bits: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the prescaler value for the capacitive scanning.\n This triggers a call to `CSD_SetPrescaler(prescaler)`\n on the device.\n\n @param prescaler The prescaler value. Valid values are\n between 0 and 8, inclusive, and map directly to values\n `CSD_PRESCALER_1` to `CSD_PRESCALER_256`.\n @return 0 on success, or an error code otherwise."]
    #[link_name = "\u{1}_ZN5Trill12setPrescalerEh"]
    pub fn Trill_setPrescaler(this: *mut Trill, prescaler: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the noise threshold for the capacitive channels.\n\n When a channel's scan returns a value smaller than the\n threshold, its value is set to 0.\n\n @param threshold the noise threshold level. Valid values are\n between 0 and `255.0/(1 << numBits)`.\n The value is internally converted to an 8-bit integer by\n multiplying it times `1 << numBits` before being sent to the device.\n On the device, the received value is used to set the\n `CSD_bNoiseThreshold` variable.\n @return 0 on success, or an error code otherwise."]
    #[link_name = "\u{1}_ZN5Trill17setNoiseThresholdEf"]
    pub fn Trill_setNoiseThreshold(this: *mut Trill, threshold: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the IDAC value for the device.\n\n This triggers a call to `CSD_SetIdacValue(value)` on the device.\n\n @param value the IDAC value. Valid values are between 0 and 255.\n @return 0 on success, or an error code otherwise."]
    #[link_name = "\u{1}_ZN5Trill12setIDACValueEh"]
    pub fn Trill_setIDACValue(this: *mut Trill, value: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set minimum touch size\n\n Sets the minimum touch size below which a touch is ignored.\n @return 0 on success, or an error code otherwise.\n"]
    #[link_name = "\u{1}_ZN5Trill19setMinimumTouchSizeEf"]
    pub fn Trill_setMinimumTouchSize(this: *mut Trill, minSize: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the device to scan automatically at the specified intervals.\n\n @param interval The scanning period, measured in ticks of a\n 32kHz clock. This effective scanning period will be limited\n by the scanning speed, bit depth and any computation\n happening on the device (such as touch detection). A value\n of 0 disables auto scanning.\n @return 0 on success, or an error code otherwise."]
    #[link_name = "\u{1}_ZN5Trill19setAutoScanIntervalEt"]
    pub fn Trill_setAutoScanInterval(this: *mut Trill, interval: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Centroid Mode\n @{\n\n When the device is in #CENTROID mode, touches are\n detected as discrete entities and can be retrieved with\n the methods in this section.\n\n The `location` of a touch is a normalised value where `0` and\n `1` are the extremes of the axis.\n\n The `size` of a touch is a rescaled value of the total\n activation measured on the sensing channels that contribute\n to the touch. The amount of activation for a touch of a\n given size is dependent (among other things) on the geometry\n of the device. The values used here have been determined\n empirically.\n\n A `compoundTouch` is a single touch represntation obtained\n by averaging the location and size of the touches on each\n axis and their size.\n This is most useful for 2-axes devices, in order to get a\n single touch.\n\n @class TAGS_1d\n \\note It is only valid to call this method if one of is1D() and\n is2D() returns `true`.\n @class TAGS_2d\n \\note It is only valid to call this method is2D() returns `true`\n/\n/**\n Does the device have one axis of position sensing?\n\n @return `true` if the device has one axis of position sensing\n and is set in #CENTROID mode, `false`\n otherwise."]
    #[link_name = "\u{1}_ZN5Trill4is1DEv"]
    pub fn Trill_is1D(this: *mut Trill) -> bool;
}
extern "C" {
    #[doc = " Does the device have two axes of position sensing?\n\n @return `true` if the device has two axes of position sensing\n and is set in #CENTROID mode, `false`\n otherwise."]
    #[link_name = "\u{1}_ZN5Trill4is2DEv"]
    pub fn Trill_is2D(this: *mut Trill) -> bool;
}
extern "C" {
    #[doc = " Get the number of touches currently active on the\n vertical axis of the device.\n\n \\copydoc TAGS_1d"]
    #[link_name = "\u{1}_ZN5Trill13getNumTouchesEv"]
    pub fn Trill_getNumTouches(this: *mut Trill) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the location of a touch on the vertical axis of the\n device.\n\n \\copydoc TAGS_1d\n\n @param touch_num the number of the touch. This value needs\n to be comprised between 0 and `getNumTouches() - 1`.\n @return the position of the touch relative to the axis, or\n -1 if no such touch exists."]
    #[link_name = "\u{1}_ZN5Trill13touchLocationEh"]
    pub fn Trill_touchLocation(this: *mut Trill, touch_num: u8) -> f32;
}
extern "C" {
    #[doc = " Get the size of a touch.\n\n \\copydoc TAGS_1d\n\n @return the size of the touch, if the touch exists, or 0\n otherwise."]
    #[link_name = "\u{1}_ZN5Trill9touchSizeEh"]
    pub fn Trill_touchSize(this: *mut Trill, touch_num: u8) -> f32;
}
extern "C" {
    #[doc = " Get the number of touches currently active on the\n horizontal axis of the device.\n\n \\copydoc TAGS_2d"]
    #[link_name = "\u{1}_ZN5Trill23getNumHorizontalTouchesEv"]
    pub fn Trill_getNumHorizontalTouches(this: *mut Trill) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the location of a touch on the horizontal axis of the\n device.\n\n \\copydoc TAGS_2d\n\n @param touch_num the number of the touch. This value needs\n to be comprised between 0 and `getNumHorizontalTouches() - 1`.\n @return the position of the touch relative to the axis, or\n -1 if no such touch exists."]
    #[link_name = "\u{1}_ZN5Trill23touchHorizontalLocationEh"]
    pub fn Trill_touchHorizontalLocation(this: *mut Trill, touch_num: u8) -> f32;
}
extern "C" {
    #[doc = " Get the size of a touch.\n\n \\copydoc TAGS_2d\n\n @return the size of the touch, if the touch exists, or 0\n otherwise."]
    #[link_name = "\u{1}_ZN5Trill19touchHorizontalSizeEh"]
    pub fn Trill_touchHorizontalSize(this: *mut Trill, touch_num: u8) -> f32;
}
extern "C" {
    #[doc = " Get the vertical location of the compound touch on the\n device.\n\n \\copydoc TAGS_1d"]
    #[link_name = "\u{1}_ZN5Trill21compoundTouchLocationEv"]
    pub fn Trill_compoundTouchLocation(this: *mut Trill) -> f32;
}
extern "C" {
    #[doc = " Get the horizontal location of the compound touch on the\n device.\n\n \\copydoc TAGS_1d"]
    #[link_name = "\u{1}_ZN5Trill31compoundTouchHorizontalLocationEv"]
    pub fn Trill_compoundTouchHorizontalLocation(this: *mut Trill) -> f32;
}
extern "C" {
    #[doc = " Get the size of the compound touch on the\n device.\n\n \\copydoc TAGS_1d"]
    #[link_name = "\u{1}_ZN5Trill17compoundTouchSizeEv"]
    pub fn Trill_compoundTouchSize(this: *mut Trill) -> f32;
}
extern "C" {
    #[doc = " Get the value of the capacitive \"button\" channels on the\n device\n\n @param button_num the button number. Valid values are\n comprised between `0` and `getNumButtons() - 1`.\n @return The differential reading on the button, normalised\n between 0 and 1."]
    #[link_name = "\u{1}_ZN5Trill14getButtonValueEh"]
    pub fn Trill_getButtonValue(this: *mut Trill, button_num: u8) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TrillC1Ev"]
    pub fn Trill_Trill(this: *mut Trill);
}
extern "C" {
    #[doc = " Initialise the device.\n\n @param i2c_bus the bus that the device is connected to.\n @param device the device type. If #UNKNOWN is passed, then\n the \\p i2c_address parameter has to be a valid address, and\n any detected device type will be accepted. If something else\n than #UNKNOWN is passed, and the detected device type is\n different from the requested one, the function will fail and\n the object will be left uninitialised.\n @param i2c_address the address at which the device can be\n found. If `255` or no value is passed, the default address\n for the specified device type will be used."]
    #[link_name = "\u{1}_ZN5TrillC1EjNS_6DeviceEh"]
    pub fn Trill_Trill1(
        this: *mut Trill,
        i2c_bus: ::std::os::raw::c_uint,
        device: Trill_Device,
        i2c_address: u8,
    );
}
impl Trill {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        i2c_bus: ::std::os::raw::c_uint,
        device: Trill_Device,
        i2c_address: u8,
    ) -> ::std::os::raw::c_int {
        Trill_setup(self, i2c_bus, device, i2c_address)
    }
    #[inline]
    pub unsafe fn probe(i2c_bus: ::std::os::raw::c_uint, i2c_address: u8) -> Trill_Device {
        Trill_probe(i2c_bus, i2c_address)
    }
    #[inline]
    pub unsafe fn updateBaseline(&mut self) -> ::std::os::raw::c_int {
        Trill_updateBaseline(self)
    }
    #[inline]
    pub unsafe fn readI2C(&mut self) -> ::std::os::raw::c_int {
        Trill_readI2C(self)
    }
    #[inline]
    pub unsafe fn newData(&mut self, newData: *const u8, len: usize) {
        Trill_newData(self, newData, len)
    }
    #[inline]
    pub unsafe fn prepareForDataRead(&mut self) -> ::std::os::raw::c_int {
        Trill_prepareForDataRead(self)
    }
    #[inline]
    pub unsafe fn getNameFromDevice(device: Trill_Device) -> *const std_string {
        Trill_getNameFromDevice(device)
    }
    #[inline]
    pub unsafe fn getDeviceFromName(name: *const std_string) -> Trill_Device {
        Trill_getDeviceFromName(name)
    }
    #[inline]
    pub unsafe fn getNameFromMode(mode: Trill_Mode) -> *const std_string {
        Trill_getNameFromMode(mode)
    }
    #[inline]
    pub unsafe fn getModeFromName(name: *const std_string) -> Trill_Mode {
        Trill_getModeFromName(name)
    }
    #[inline]
    pub unsafe fn printDetails(&mut self) {
        Trill_printDetails(self)
    }
    #[inline]
    pub unsafe fn getNumChannels(&mut self) -> ::std::os::raw::c_uint {
        Trill_getNumChannels(self)
    }
    #[inline]
    pub unsafe fn setMode(&mut self, mode: Trill_Mode) -> ::std::os::raw::c_int {
        Trill_setMode(self, mode)
    }
    #[inline]
    pub unsafe fn setScanSettings(&mut self, speed: u8, num_bits: u8) -> ::std::os::raw::c_int {
        Trill_setScanSettings(self, speed, num_bits)
    }
    #[inline]
    pub unsafe fn setPrescaler(&mut self, prescaler: u8) -> ::std::os::raw::c_int {
        Trill_setPrescaler(self, prescaler)
    }
    #[inline]
    pub unsafe fn setNoiseThreshold(&mut self, threshold: f32) -> ::std::os::raw::c_int {
        Trill_setNoiseThreshold(self, threshold)
    }
    #[inline]
    pub unsafe fn setIDACValue(&mut self, value: u8) -> ::std::os::raw::c_int {
        Trill_setIDACValue(self, value)
    }
    #[inline]
    pub unsafe fn setMinimumTouchSize(&mut self, minSize: f32) -> ::std::os::raw::c_int {
        Trill_setMinimumTouchSize(self, minSize)
    }
    #[inline]
    pub unsafe fn setAutoScanInterval(&mut self, interval: u16) -> ::std::os::raw::c_int {
        Trill_setAutoScanInterval(self, interval)
    }
    #[inline]
    pub unsafe fn is1D(&mut self) -> bool {
        Trill_is1D(self)
    }
    #[inline]
    pub unsafe fn is2D(&mut self) -> bool {
        Trill_is2D(self)
    }
    #[inline]
    pub unsafe fn getNumTouches(&mut self) -> ::std::os::raw::c_uint {
        Trill_getNumTouches(self)
    }
    #[inline]
    pub unsafe fn touchLocation(&mut self, touch_num: u8) -> f32 {
        Trill_touchLocation(self, touch_num)
    }
    #[inline]
    pub unsafe fn touchSize(&mut self, touch_num: u8) -> f32 {
        Trill_touchSize(self, touch_num)
    }
    #[inline]
    pub unsafe fn getNumHorizontalTouches(&mut self) -> ::std::os::raw::c_uint {
        Trill_getNumHorizontalTouches(self)
    }
    #[inline]
    pub unsafe fn touchHorizontalLocation(&mut self, touch_num: u8) -> f32 {
        Trill_touchHorizontalLocation(self, touch_num)
    }
    #[inline]
    pub unsafe fn touchHorizontalSize(&mut self, touch_num: u8) -> f32 {
        Trill_touchHorizontalSize(self, touch_num)
    }
    #[inline]
    pub unsafe fn compoundTouchLocation(&mut self) -> f32 {
        Trill_compoundTouchLocation(self)
    }
    #[inline]
    pub unsafe fn compoundTouchHorizontalLocation(&mut self) -> f32 {
        Trill_compoundTouchHorizontalLocation(self)
    }
    #[inline]
    pub unsafe fn compoundTouchSize(&mut self) -> f32 {
        Trill_compoundTouchSize(self)
    }
    #[inline]
    pub unsafe fn getButtonValue(&mut self, button_num: u8) -> f32 {
        Trill_getButtonValue(self, button_num)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Trill_Trill(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        i2c_bus: ::std::os::raw::c_uint,
        device: Trill_Device,
        i2c_address: u8,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Trill_Trill1(__bindgen_tmp.as_mut_ptr(), i2c_bus, device, i2c_address);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5TrillD1Ev"]
    pub fn Trill_Trill_destructor(this: *mut Trill);
}
