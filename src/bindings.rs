/* automatically generated by rust-bindgen 0.69.4 */

pub const BELA_MAJOR_VERSION: u32 = 1;
pub const BELA_MINOR_VERSION: u32 = 13;
pub const BELA_BUGFIX_VERSION: u32 = 0;
pub const MAX_BUF: u32 = 128;
pub const MAX_PRU_FILENAME_LENGTH: u32 = 256;
pub const MAX_UNUSED_LENGTH: u32 = 224;
pub const MAX_PROJECTNAME_LENGTH: u32 = 256;
pub const BELA_AUDIO_PRIORITY: u32 = 95;
pub const DEFAULT_LINE_OUT_LEVEL: f64 = 0.0;
pub const DEFAULT_PGA_GAIN: u32 = 16;
pub const DEFAULT_HP_LEVEL: f64 = -6.0;
pub const BELA_FLAG_INTERLEAVED: u32 = 1;
pub const BELA_FLAG_ANALOG_OUTPUTS_PERSIST: u32 = 2;
pub const BELA_FLAG_DETECT_UNDERRUNS: u32 = 4;
pub const BELA_FLAG_OFFLINE: u32 = 8;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = __int64_t;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __gnuc_va_list = u32;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        152usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type va_list = __gnuc_va_list;
extern "C" {
    pub fn rt_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_fprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_vprintf(format: *const ::std::os::raw::c_char, ap: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_vfprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< No hardware"]
pub const BelaHw_BelaHw_NoHw: BelaHw = -1;
#[doc = "< Bela"]
pub const BelaHw_BelaHw_Bela: BelaHw = 0;
#[doc = "< Bela Mini"]
pub const BelaHw_BelaHw_BelaMini: BelaHw = 1;
#[doc = "< Salt"]
pub const BelaHw_BelaHw_Salt: BelaHw = 2;
#[doc = "< Ctag Face"]
pub const BelaHw_BelaHw_CtagFace: BelaHw = 3;
#[doc = "< Ctag Beast"]
pub const BelaHw_BelaHw_CtagBeast: BelaHw = 4;
#[doc = "< Ctag Face and Bela cape"]
pub const BelaHw_BelaHw_CtagFaceBela: BelaHw = 5;
#[doc = "< Ctag Beast and Bela cape"]
pub const BelaHw_BelaHw_CtagBeastBela: BelaHw = 6;
#[doc = "< Bela Mini with extra codecs"]
pub const BelaHw_BelaHw_BelaMiniMultiAudio: BelaHw = 7;
#[doc = "< Bela Mini with extra codecs and/or tdm devices"]
pub const BelaHw_BelaHw_BelaMiniMultiTdm: BelaHw = 8;
#[doc = "< Bela with extra codecs and/or tdm devices"]
pub const BelaHw_BelaHw_BelaMultiTdm: BelaHw = 9;
#[doc = "< Bela Mini with extra rx and tx I2S data lines."]
pub const BelaHw_BelaHw_BelaMiniMultiI2s: BelaHw = 10;
#[doc = "< A Bela cape with Es9080 EVB on top, all as audio"]
pub const BelaHw_BelaHw_BelaEs9080: BelaHw = 11;
#[doc = "< A Bela cape rev C: Es9080 is used for analog outs"]
pub const BelaHw_BelaHw_BelaRevC: BelaHw = 12;
#[doc = "< Dummy offline"]
pub const BelaHw_BelaHw_Batch: BelaHw = 13;
#[doc = " A type of Bela hardware."]
pub type BelaHw = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BelaHwConfig {
    pub audioSampleRate: f32,
    pub audioInChannels: ::std::os::raw::c_uint,
    pub audioOutChannels: ::std::os::raw::c_uint,
    pub analogInChannels: ::std::os::raw::c_uint,
    pub analogOutChannels: ::std::os::raw::c_uint,
    pub digitalChannels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__BelaHwConfig() {
    const UNINIT: ::std::mem::MaybeUninit<_BelaHwConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_BelaHwConfig>(),
        24usize,
        concat!("Size of: ", stringify!(_BelaHwConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_BelaHwConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(_BelaHwConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioSampleRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_BelaHwConfig),
            "::",
            stringify!(audioSampleRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioInChannels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_BelaHwConfig),
            "::",
            stringify!(audioInChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioOutChannels) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_BelaHwConfig),
            "::",
            stringify!(audioOutChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogInChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_BelaHwConfig),
            "::",
            stringify!(analogInChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogOutChannels) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_BelaHwConfig),
            "::",
            stringify!(analogOutChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalChannels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_BelaHwConfig),
            "::",
            stringify!(digitalChannels)
        )
    );
}
pub type BelaHwConfig = _BelaHwConfig;
extern "C" {
    #[doc = " Returns the configuration for a given BelaHw or `nullptr` if `hw` is\n invalid.\n\n The returned pointer has to be deleted with Bela_HwConfig_delete()."]
    pub fn Bela_HwConfig_new(hw: BelaHw) -> *mut BelaHwConfig;
}
extern "C" {
    #[doc = " Use this to delete a pointer returned by Bela_HwConfig_new()"]
    pub fn Bela_HwConfig_delete(cfg: *mut BelaHwConfig);
}
#[doc = "< perform an automatic detection by scanning the peripherals and busses available, and cache value in `/run/bela/belaconfig`"]
pub const BelaHwDetectMode_BelaHwDetectMode_Scan: BelaHwDetectMode = 0;
#[doc = "< read cached value from `/run/bela/belaconfig` first. If it does not exist, fall back to #BelaHwDetectMode_Scan"]
pub const BelaHwDetectMode_BelaHwDetectMode_Cache: BelaHwDetectMode = 1;
#[doc = "<read cached value from `/run/bela/belaconfig`. If it does not exist, return #BelaHw_NoHw"]
pub const BelaHwDetectMode_BelaHwDetectMode_CacheOnly: BelaHwDetectMode = 2;
#[doc = "<read user-specified value from `~/.bela/belaconfig`. If it does not exist, fall back to #BelaHwDetectMode_Cache"]
pub const BelaHwDetectMode_BelaHwDetectMode_User: BelaHwDetectMode = 3;
#[doc = "<read user-specified value from `~/.bela/belaconfig`. If it does not exist, return #BelaHw_NoHw"]
pub const BelaHwDetectMode_BelaHwDetectMode_UserOnly: BelaHwDetectMode = 4;
#[doc = " Arguments to be passed to Bela_detectHw()"]
pub type BelaHwDetectMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    _unused: [u8; 0],
}
#[doc = " \\ingroup render\n \\brief Structure holding audio and sensor settings and pointers to I/O data buffers.\n\n This structure is passed to setup(), render() and cleanup() and provides access to\n Bela's I/O functionality. It is initialised in Bela_initAudio() based on the contents\n of the BelaInitSettings structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BelaContext {
    #[doc = " \\brief Buffer holding audio input samples\n\n This buffer allows Bela's audio input data to be read during render().\n By default the buffer contains data from all the audio input channels arranged\n in interleaved format.\n\n Every time render() runs this buffer is filled with a block of new audio samples.\n The block is made up of frames, individual slices of time consisting of one sample\n taken from each audio input channel simultaneously. The number of frames per\n block is given by context->audioFrames, and the number of audio input channels\n by context->audioInChannels. The length of this buffer is the product of these\n two values.\n\n The buffer can be accessed manually with standard array notation or more\n conveniently using the audioRead() utility.\n\n \\b Note: this element is available in render() only."]
    pub audioIn: *const f32,
    #[doc = " \\brief Buffer holding audio output samples\n\n This buffer allows Bela's audio output data to be written during render().\n By default the buffer must contain data from all the audio output channels\n arranged in interleaved format.\n\n Every time render() runs it is the job of the developer to fill this buffer with\n a block of new audio samples, structured in the same way as context->audioIn.\n\n The buffer can be accessed manually with standard array notation or more\n conveniently using the audioWrite() utility.\n\n \\b Note: this element is available in render() only."]
    pub audioOut: *mut f32,
    #[doc = " \\brief Buffer holding analog input samples\n\n This buffer allows Bela's analog input data to be read during render().\n By default the buffer contains data from all the analog input channels arranged\n in interleaved format.\n\n Every time render() runs this buffer is filled with a block of new analog samples.\n The block is made up of frames, individual slices of time consisting of one sample\n taken from each analog input channel simultaneously. The number of frames per\n block is given by context->analogFrames, and the number of analog input channels\n by context->analogInChannels. The length of this buffer is the product of these\n two values.\n\n The buffer can be accessed manually with standard array notation or more\n conveniently using the analogRead() utility.\n\n \\b Note: this element is available in render() only."]
    pub analogIn: *const f32,
    #[doc = " \\brief Buffer holding analog output samples\n\n This buffer allows Bela's analog output data to be written during render().\n By default the buffer must contain data from all the analog output channels\n arranged in interleaved format.\n\n Every time render() runs it is the job of the developer to fill this buffer with\n a block of new analog samples, structured in the same way as context->analogIn.\n\n The buffer can be accessed manually with standard array notation or more\n conveniently using the analogWrite() utility.\n\n \\b Note: this element is available in render() only."]
    pub analogOut: *mut f32,
    #[doc = " \\brief Buffer holding digital input/output samples\n\n This buffer allows Bela's digital GPIO data to be read and written during render().\n\n The buffer can be accessed manually with standard array notation or somewhat more\n conveniently using the digitalRead() and digitalWrite() utilities.\n\n \\b Note: this element is available in render() only."]
    pub digital: *mut u32,
    #[doc = " \\brief The number of audio frames per block\n\n Every time render() runs context->audioIn is filled with a block of new audio\n samples. The block is made up of frames, individual slices of time consisting of\n one sample taken from each audio input channel simultaneously.\n\n This value determines the number of audio frames in each block and can be adjusted\n in the IDE settings tab (or via the command line arguments) from 2 to 128,\n defaulting to 16.\n\n This value also determines how often render() is called, and reducing it decreases\n audio latency at the cost of increased CPU consumption."]
    pub audioFrames: u32,
    #[doc = " \\brief The number of audio input channels"]
    pub audioInChannels: u32,
    #[doc = " \\brief The number of audio output channels"]
    pub audioOutChannels: u32,
    #[doc = " \\brief The audio sample rate in Hz (currently always 44100.0)"]
    pub audioSampleRate: f32,
    #[doc = " \\brief The number of analog frames per block\n\n Every time render() runs context->analogIn is filled with a block of new analog\n samples. The block is made up of frames, individual slices of time consisting of\n one sample taken from each analog input channel simultaneously.\n\n This value determines the number of analog frames in each block. It cannot be\n set directly as it is dependant on the number of audio frames per block\n (context->audioFrames) and the analog sample rate (context->analogSampleRate).\n\n This value will be 0 if analog I/O is disabled."]
    pub analogFrames: u32,
    #[doc = " \\brief The number of analog input channels\n\n This will be 0 if analog I/O is disabled."]
    pub analogInChannels: u32,
    #[doc = " \\brief The number of analog output channels\n\n This will be 0 if analog I/O is disabled."]
    pub analogOutChannels: u32,
    #[doc = " \\brief Analog sample rate in Hz\n\n This value determines the rate at which each analog input is sampled, and is\n directly related to the number of analog channels available. It can be adjusted\n in the IDE settings tab (or via the command line arguments) to 22050, 44100\n or 88200, allowing 8, 4, or 2 analog channels respectively. By default, all 8\n channels are sampled at 22050Hz.\n\n If analog I/O is disabled, this value is 0."]
    pub analogSampleRate: f32,
    #[doc = " Number of digital frames per period"]
    pub digitalFrames: u32,
    #[doc = " \\brief Number of digital channels\n\n Currently this will always be 16, unless digital I/O is disabled, in which case it will be 0."]
    pub digitalChannels: u32,
    #[doc = " Digital sample rate in Hz (currently always 44100.0)"]
    pub digitalSampleRate: f32,
    #[doc = " \\brief Number of elapsed audio frames since the start of rendering.\n\n This holds the total number of audio frames as of the beginning of the current block. To\n find the current number of analog or digital frames elapsed, multiply by the ratio of the\n sample rates (e.g. half the number of analog frames will have elapsed if the analog sample\n rate is 22050)."]
    pub audioFramesElapsed: u64,
    #[doc = " \\brief Number of multiplexer channels for each analog input.\n\n This will be 2, 4 or 8 if the multiplexer capelet is enabled, otherwise it will be 1.\n 2, 4 and 8 correspond to 16, 32 and 64 analog inputs, respectively."]
    pub multiplexerChannels: u32,
    #[doc = " \\brief Multiplexer channel corresponding to the first analog frame.\n\n This indicates the multiplexer setting corresponding to the first analog frame in the\n buffer."]
    pub multiplexerStartingChannel: u32,
    #[doc = " \\brief Buffer which holds multiplexed analog inputs, when multiplexer capelet is enabled.\n\n Because the analog in buffer size may be smaller than a complete cycle of the multiplexer\n capelet, this buffer will always be big enough to hold at least one complete cycle of all\n channels. It will be null if the multiplexer capelet is not enabled."]
    pub multiplexerAnalogIn: *const f32,
    #[doc = " \\brief Flags for whether audio expander is enabled on given analog channels.\n\n Bits 0-15, when set, indicate audio expander enabled on the analog inputs. Bits 16-31\n indicate audio expander enabled on the analog outputs."]
    pub audioExpanderEnabled: u32,
    #[doc = " \\brief Other audio/sensor settings\n\n Binary combination of flags including:\n\n BELA_FLAG_INTERLEAVED\n BELA_FLAG_ANALOG_OUTPUTS_PERSIST\n BELA_FLAG_DETECT_UNDERRUNS\n BELA_FLAG_OFFLINE"]
    pub flags: u32,
    #[doc = " Name of running project."]
    pub projectName: [::std::os::raw::c_char; 256usize],
    #[doc = " Number of detected underruns."]
    pub underrunCount: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_BelaContext() {
    const UNINIT: ::std::mem::MaybeUninit<BelaContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BelaContext>(),
        352usize,
        concat!("Size of: ", stringify!(BelaContext))
    );
    assert_eq!(
        ::std::mem::align_of::<BelaContext>(),
        8usize,
        concat!("Alignment of ", stringify!(BelaContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioIn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioOut) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioOut)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogIn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogOut) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogOut)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digital) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digital)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioFrames) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioInChannels) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioInChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioOutChannels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioOutChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioSampleRate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioSampleRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogFrames) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogInChannels) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogInChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogOutChannels) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogOutChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogSampleRate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogSampleRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalFrames) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digitalFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalChannels) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digitalChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digitalSampleRate) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digitalSampleRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioFramesElapsed) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioFramesElapsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiplexerChannels) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(multiplexerChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiplexerStartingChannel) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(multiplexerStartingChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiplexerAnalogIn) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(multiplexerAnalogIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioExpanderEnabled) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioExpanderEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).projectName) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(projectName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).underrunCount) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(underrunCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BelaChannelGain {
    #[doc = "< Channel number. Negative value means all the channels"]
    pub channel: ::std::os::raw::c_int,
    #[doc = "< Gain in dB."]
    pub gain: f32,
}
#[test]
fn bindgen_test_layout_BelaChannelGain() {
    const UNINIT: ::std::mem::MaybeUninit<BelaChannelGain> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BelaChannelGain>(),
        8usize,
        concat!("Size of: ", stringify!(BelaChannelGain))
    );
    assert_eq!(
        ::std::mem::align_of::<BelaChannelGain>(),
        4usize,
        concat!("Alignment of ", stringify!(BelaChannelGain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaChannelGain),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gain) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaChannelGain),
            "::",
            stringify!(gain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BelaChannelGainArray {
    pub length: ::std::os::raw::c_uint,
    pub data: *mut BelaChannelGain,
}
#[test]
fn bindgen_test_layout_BelaChannelGainArray() {
    const UNINIT: ::std::mem::MaybeUninit<BelaChannelGainArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BelaChannelGainArray>(),
        8usize,
        concat!("Size of: ", stringify!(BelaChannelGainArray))
    );
    assert_eq!(
        ::std::mem::align_of::<BelaChannelGainArray>(),
        4usize,
        concat!("Alignment of ", stringify!(BelaChannelGainArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaChannelGainArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaChannelGainArray),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\ingroup control\n \\brief Structure containing initialisation parameters for the real-time\n audio control system.\n\n This structure is initialised using Bela_defaultSettings(). Its contents\n are used up through the point of calling\n Bela_initAudio() at which point it is no longer needed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BelaInitSettings {
    #[doc = " \\brief Number of audio frames per period (\"blocksize\").\n\n The number of analog frames depends on relative sample rates of the\n two. By default, audio is twice the sample rate, so has twice the\n period size."]
    pub periodSize: ::std::os::raw::c_int,
    #[doc = " Whether to use the analog input and output"]
    pub useAnalog: ::std::os::raw::c_int,
    #[doc = " Whether to use the 16 programmable GPIOs"]
    pub useDigital: ::std::os::raw::c_int,
    #[doc = " How many audio input channels [ignored]"]
    pub numAudioInChannels: ::std::os::raw::c_int,
    #[doc = " How many audio out channels [ignored]"]
    pub numAudioOutChannels: ::std::os::raw::c_int,
    #[doc = " How many analog input channels"]
    pub numAnalogInChannels: ::std::os::raw::c_int,
    #[doc = " How many analog output channels"]
    pub numAnalogOutChannels: ::std::os::raw::c_int,
    #[doc = " How many channels for the GPIOs"]
    pub numDigitalChannels: ::std::os::raw::c_int,
    #[doc = " Whether to begin with the speakers muted"]
    pub beginMuted: ::std::os::raw::c_int,
    #[doc = " Level for the audio DAC output. DEPRECATED: ues lineOutGains"]
    pub dacLevel: f32,
    #[doc = " Level for the audio ADC input. DEPRECATED: use audioInputGains"]
    pub adcLevel: f32,
    #[doc = " Gains for the PGA, left and right channels. DEPRECATED: use audioInputGains"]
    pub pgaGain: [f32; 2usize],
    #[doc = " Level for the headphone output. DEPRECATED: use headphoneGains"]
    pub headphoneLevel: f32,
    #[doc = " How many channels to use on the multiplexer capelet, if enabled"]
    pub numMuxChannels: ::std::os::raw::c_int,
    #[doc = " Which audio expander settings to use on the input"]
    pub audioExpanderInputs: ::std::os::raw::c_uint,
    #[doc = " Which audio expander settings to use on the input"]
    pub audioExpanderOutputs: ::std::os::raw::c_uint,
    #[doc = " Which PRU (0 or 1) the code should run on"]
    pub pruNumber: ::std::os::raw::c_int,
    #[doc = " The external .bin file to load. If empty will use PRU code from pru_rtaudio_bin.h"]
    pub pruFilename: [::std::os::raw::c_char; 256usize],
    #[doc = " Whether to detect and log underruns"]
    pub detectUnderruns: ::std::os::raw::c_int,
    #[doc = " Whether to use verbose logging"]
    pub verbose: ::std::os::raw::c_int,
    #[doc = " Whether to use the blinking LED to indicate Bela is running"]
    pub enableLED: ::std::os::raw::c_int,
    #[doc = " What GPIO pin to monitor for stopping the program. Defaults to 115\n (button on P9.27/P2.34/GPIO3[19]). Pass -1 to disable monitoring."]
    pub stopButtonPin: ::std::os::raw::c_int,
    #[doc = " Whether to use high-performance mode: gives more CPU to\n the Bela task. The Linux part of the board and the IDE may\n freeze while the program is running. Use the button on the\n Bela cape to forcefully stop the running program"]
    pub highPerformanceMode: ::std::os::raw::c_int,
    #[doc = " Whether audio/analog data should be interleaved"]
    pub interleave: ::std::os::raw::c_int,
    #[doc = " \\brief Whether analog outputs should persist to future frames.\n\n n.b. digital pins always persist, audio never does"]
    pub analogOutputsPersist: ::std::os::raw::c_int,
    #[doc = " \\brief Whether the analog channels should be resampled to\n audio sampling rate."]
    pub uniformSampleRate: ::std::os::raw::c_int,
    #[doc = " \\brief The requested stack size for the audio thread. Defaults"]
    pub audioThreadStackSize: ::std::os::raw::c_uint,
    #[doc = " \\brief The requested stack size for each AuxilaryTask. Defaults"]
    pub auxiliaryTaskStackSize: ::std::os::raw::c_uint,
    pub setup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut BelaContext, arg2: *mut ::std::os::raw::c_void) -> bool,
    >,
    pub render: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut BelaContext, arg2: *mut ::std::os::raw::c_void),
    >,
    pub cleanup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut BelaContext, arg2: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Pin where amplifier mute can be found"]
    pub ampMutePin: ::std::os::raw::c_int,
    #[doc = " Pointer to an optional function to be called when the audio thread is done.\n This function is called from the audio thread itself just before it returns."]
    pub audioThreadDone: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut BelaContext, arg2: *mut ::std::os::raw::c_void),
    >,
    #[doc = " A codec-specific intialisation parameter"]
    pub codecMode: *mut ::std::os::raw::c_char,
    #[doc = " audio input gains"]
    pub audioInputGains: BelaChannelGainArray,
    #[doc = " level for headphone outputs"]
    pub headphoneGains: BelaChannelGainArray,
    #[doc = " Level for the audio ADC input DEPRECATED: use audioInputGains"]
    pub adcGains: BelaChannelGainArray,
    #[doc = " Level for the audio line level output"]
    pub lineOutGains: BelaChannelGainArray,
    pub unused: [::std::os::raw::c_char; 224usize],
    #[doc = " User selected board to work with (as opposed to detected hardware)."]
    pub board: BelaHw,
    #[doc = " Name of running project."]
    pub projectName: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BelaInitSettings() {
    const UNINIT: ::std::mem::MaybeUninit<BelaInitSettings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BelaInitSettings>(),
        656usize,
        concat!("Size of: ", stringify!(BelaInitSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<BelaInitSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(BelaInitSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(periodSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useAnalog) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(useAnalog)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useDigital) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(useDigital)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAudioInChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAudioInChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAudioOutChannels) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAudioOutChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAnalogInChannels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAnalogInChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAnalogOutChannels) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAnalogOutChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numDigitalChannels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numDigitalChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beginMuted) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(beginMuted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dacLevel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(dacLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adcLevel) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(adcLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pgaGain) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(pgaGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headphoneLevel) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(headphoneLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numMuxChannels) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numMuxChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioExpanderInputs) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioExpanderInputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioExpanderOutputs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioExpanderOutputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pruNumber) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(pruNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pruFilename) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(pruFilename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detectUnderruns) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(detectUnderruns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableLED) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(enableLED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stopButtonPin) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(stopButtonPin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).highPerformanceMode) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(highPerformanceMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interleave) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(interleave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analogOutputsPersist) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(analogOutputsPersist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniformSampleRate) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(uniformSampleRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioThreadStackSize) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioThreadStackSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auxiliaryTaskStackSize) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(auxiliaryTaskStackSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setup) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).render) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(render)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cleanup) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ampMutePin) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(ampMutePin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioThreadDone) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioThreadDone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codecMode) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(codecMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioInputGains) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioInputGains)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headphoneGains) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(headphoneGains)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adcGains) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(adcGains)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lineOutGains) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(lineOutGains)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).board) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(board)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).projectName) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(projectName)
        )
    );
}
#[doc = " \\ingroup auxtask\n\n Auxiliary task variable. Auxiliary tasks are created using createAuxiliaryTask() and\n automatically cleaned up after cleanup() finishes."]
pub type AuxiliaryTask = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " \\brief Allocate the data structure containing settings for Bela.\n\n This function should be used to allocate the structure that holds initialisation\n data for Bela in order to preserve binary compatibility across versions of\n the library."]
    pub fn Bela_InitSettings_alloc() -> *mut BelaInitSettings;
}
extern "C" {
    #[doc = " \\brief De-allocate the data structure containing settings for Bela.\n\n This function should be used to de-allocate the structure that holds initialisation\n data for Bela.\n\n \\param settings Pointer to structure to be de-allocated."]
    pub fn Bela_InitSettings_free(settings: *mut BelaInitSettings);
}
extern "C" {
    #[doc = " \\brief Initialise the data structure containing settings for Bela.\n\n This function should be called in main() before parsing any command-line arguments. It\n sets default values in the data structure which specifies the Bela settings, including\n frame sizes, numbers of channels, volume levels and other parameters.\n\n \\param settings Structure holding initialisation data for Bela."]
    pub fn Bela_defaultSettings(settings: *mut BelaInitSettings);
}
extern "C" {
    #[doc = " \\brief Initialise the data structure containing settings for Bela.\n\n This function fwill be called by Bela_defaultSettings() after the settings have been\n initialied. It has weak linking so the user is free - but not forced to - define it.\n It can be used to override some of the default settings if the user code does not have\n access to the call to Bela_defaultSettings() (e.g.: because it is handled by the backend\n code).\n\n \\param settings Structure holding initialisation data for Bela."]
    pub fn Bela_userSettings(settings: *mut BelaInitSettings);
}
extern "C" {
    #[doc = " \\brief Get long options from command line argument list, including Bela standard options\n\n This function should be used in main() to process command line options, in place of the\n standard library getopt_long(). Internally, it parses standard Bela command-line options,\n storing the results in the settings data structure. Any options which are not part of the\n Bela standard options will be returned, as they would normally be in getopt_long().\n\n \\param argc Number of command line options, as passed to main().\n \\param argv Array of command line options, as passed to main().\n \\param customShortOptions List of short options to be parsed, analogous to getopt_long(). This\n list should not include any characters already parsed as part of the Bela standard options.\n \\param customLongOptions List of long options to parsed, analogous to getopt_long(). This\n list should not include any long options already parsed as part of the Bela standard options.\n \\param settings Data structure holding initialisation settings for Bela. Any standard options\n parsed will automatically update this data structure.\n\n \\return Value of the next option parsed which is not a Bela standard option, or -1 when the\n argument list has been exhausted. Similar to the return value of getopt_long() except that Bela\n standard options are handled internally and not returned."]
    pub fn Bela_getopt_long(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        customShortOptions: *const ::std::os::raw::c_char,
        customLongOptions: *const option,
        settings: *mut BelaInitSettings,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Print usage information for Bela standard options.\n\n This function should be called from your code wherever you wish to print usage information for the\n user. It will print usage information on Bela standard options, after which you can print usage\n information for your own custom options."]
    pub fn Bela_usage();
}
extern "C" {
    #[doc = " \\brief Get the version of Bela you are running."]
    pub fn Bela_getVersion(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        bugfix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set level of verbose (debugging) printing.\n\n \\param level Verbosity level of the internal Bela system. 0 by default; higher values will\n print more information. Presently all positive numbers produce the same level of printing."]
    pub fn Bela_setVerboseLevel(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Detect what hardware we are running on.\n\n\n \\param mode How to perform the detection. The behaviour is described in #BelaHwDetectMode."]
    pub fn Bela_detectHw(mode: BelaHwDetectMode) -> BelaHw;
}
extern "C" {
    #[doc = " \\brief Initialise audio and sensor rendering environment.\n\n This function prepares audio rendering in Bela. It should be called from main() sometime\n after command line option parsing has finished. It will initialise the rendering system, which\n in the process will result in a call to the user-defined setup() function.\n\n \\param settings Data structure holding system settings, including numbers of channels, frame sizes,\n volume levels and other information.\n \\param userData An opaque pointer to a user-defined data structure which will be passed to\n setup(), render() and cleanup(). You can use this to pass custom information\n to the rendering functions, as an alternative to using global variables.\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_initAudio(
        settings: *mut BelaInitSettings,
        userData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Begin processing audio and sensor data.\n\n This function will start the Bela audio/sensor system. After this function is called, the\n system will make periodic calls to render() until Bela_stopAudio() is called.\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_startAudio() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Begin processing audio and sensor data in the same thread as the caller.\n\n This function will start the Bela audio/sensor system. After this function is called, the\n system will make periodic calls to render() until Bela_stopAudio() is called.\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_runInSameThread() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stop processing audio and sensor data.\n\n This function will stop the Bela audio/sensor system. After this function returns, no further\n calls to render() will be issued."]
    pub fn Bela_stopAudio();
}
extern "C" {
    #[doc = " \\brief Clean up resources from audio and sensor processing.\n\n This function should only be called after Bela_stopAudio(). It will release any\n internal resources for audio and sensor processing. In the process, it will call the\n user-defined cleanup() function."]
    pub fn Bela_cleanupAudio();
}
extern "C" {
    #[doc = " \\brief Set the `userData` variable, which is passed to setup(), render() and cleanup().\n\n This function can be used to override `userData` after it has been set by Bela_initAudio().\n\n \\note This function is experimental and may be removed in a future version."]
    pub fn Bela_setUserData(newUserData: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " \\brief Tell the Bela program to stop.\n\n This can be safely called anywhere in the code to tell the audio thread, and\n all threads monitoring Bela_stopRequested() that they should stop at the\n earliest occasion. The program will not stop immediately. If the render()\n function is currently running, it will keep running until it concludes its\n current execution, but will not be called again. The program's execution\n will stop when all threads have completed their execution. For this reason,\n all threads should check for Bela_stopRequested() to be notified when\n Bela_requestStop() has been called."]
    pub fn Bela_requestStop();
}
extern "C" {
    #[doc = " \\brief Check whether the program should stop.\n\n If you have several threads of execution, each of them should be regularly\n calling this function and complete execution as soon as possible if a\n non-zero value is returned.\n\n @return a non-zero value if stop has been requested, 0 otherwise."]
    pub fn Bela_stopRequested() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BelaCpuData {
    #[doc = "< Number of samples (tic/toc pairs) in a acquisition cycle. Use 0 to disable."]
    pub count: ::std::os::raw::c_int,
    #[doc = "< Number of tics in current acquisition cycle"]
    pub currentCount: ::std::os::raw::c_uint,
    #[doc = "< Total CPU time spent being busy (between tic and toc) during the current acquisition cycle"]
    pub busy: ::std::os::raw::c_ulonglong,
    #[doc = "< Total CPU time (between tic and previous tic) during the current acquisition cycle"]
    pub total: ::std::os::raw::c_ulonglong,
    #[doc = "< Time of last tic"]
    pub tic: timespec,
    #[doc = "< Time of last toc"]
    pub toc: timespec,
    #[doc = "< Average CPU usage during previous acquisition cycle"]
    pub percentage: f32,
}
#[test]
fn bindgen_test_layout_BelaCpuData() {
    const UNINIT: ::std::mem::MaybeUninit<BelaCpuData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BelaCpuData>(),
        48usize,
        concat!("Size of: ", stringify!(BelaCpuData))
    );
    assert_eq!(
        ::std::mem::align_of::<BelaCpuData>(),
        8usize,
        concat!("Alignment of ", stringify!(BelaCpuData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaCpuData),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaCpuData),
            "::",
            stringify!(currentCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaCpuData),
            "::",
            stringify!(busy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaCpuData),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaCpuData),
            "::",
            stringify!(tic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).toc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaCpuData),
            "::",
            stringify!(toc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentage) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaCpuData),
            "::",
            stringify!(percentage)
        )
    );
}
extern "C" {
    #[doc = " Set internal CPU monitoring for the audio thread.\n @param count Number of samples (tic/toc pairs) in a acquisition cycle. Use 0 to disable.\n @return 0 on success, an error code otherwise."]
    pub fn Bela_cpuMonitoringInit(count: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get stats about internal CPU monitoring.\n\n @return a pointer to a BelaCpuData structure which contains data about the\n CPU usage of the audio thread."]
    pub fn Bela_cpuMonitoringGet() -> *mut BelaCpuData;
}
extern "C" {
    #[doc = " Start measuring CPU time. When `data->currentCount` reaches `data->count`, a\n acquisition cycle is completed. `data->percentage` gives the average CPU busy time\n during the latest completed acquisition cycle.\n\n @param data The `count` field is an input and needs to be populated before calling. Other fields are used as I/O by the function."]
    pub fn Bela_cpuTic(data: *mut BelaCpuData);
}
extern "C" {
    #[doc = " Stop measuring CPU time.\n\n @param data The `count` field is an input and needs to be populated before calling. Other fields are used as I/O by the function."]
    pub fn Bela_cpuToc(data: *mut BelaCpuData);
}
extern "C" {
    #[doc = " \\brief Set the level of the audio line out.\n\n \\b Important: do not call this function from within render(), as it does not make\n any guarantees on real-time performance.\n\n \\param channel The channel to set. Use a negative value to set all channels.\n \\param decibels Level of the line output. Valid values will depend on the codec in use.\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_setLineOutLevel(
        channel: ::std::os::raw::c_int,
        decibel: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the level of the audio DAC.\n\n DEPRECATED.\n\n Use `Bela_setLineOutLevel()` instead."]
    pub fn Bela_setDacLevel(channel: ::std::os::raw::c_int, decibels: f32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DEPRECATED.\n\n Equivalent to `Bela_setDacLevel(-1, decibels)`."]
    pub fn Bela_setDACLevel(decibels: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the level of the audio ADC.\n\n This function sets the level of the audio input. It does not affect the level of the\n (non-audio) analog inputs.\n\n \\b Important: do not call this function from within render(), as it does not make\n any guarantees on real-time performance.\n\n \\param channel The channel to set. Use a negative value to set all channels.\n \\param decibels Level of the ADC input. Valid levels range from -12 (lowest) to\n 0 (highest) in steps of 1.5dB. Levels between increments of 1.5 will be rounded down.\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_setAdcLevel(channel: ::std::os::raw::c_int, decibels: f32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DEPRECATED.\n\n Equivalent to `Bela_setAdcLevel(-1, decibels)`."]
    pub fn Bela_setADCLevel(decibels: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the gain of the audio input preamplifier.\n\n This function sets the level of the Programmable Gain Amplifier(PGA), which\n amplifies the signal before the ADC.\n\n \\b Important: do not call this function from within render(), as it does not make\n any guarantees on real-time performance.\n\n \\param channel The channel to set. Use a negative value to set all channels.\n \\param decibels Level of the PGA Valid levels range from 0 (lowest) to\n 59.5 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded.\n channel 1 is right\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_setAudioInputGain(
        channel: ::std::os::raw::c_int,
        decibels: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DEPRECATED.\n\n Equivalent to `Bela_setAudioInputGain(channel, decibels)`."]
    pub fn Bela_setPgaGain(decibels: f32, channel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the level of the onboard headphone amplifier.\n\n This function sets the level of the headphone output only (3-pin connector on the Bela\n cape or the output jack on the BeagleBone Audio Cape). It does not affect the level of the\n speakers or the line out pads on the cape.\n\n \\b Important: do not call this function from within render(), as it does not make\n any guarantees on real-time performance.\n\n \\param channel The channel to set. Use a negative value to set all channels.\n \\param decibels Level of the headphone output. Valid levels range from -63.5 (lowest) to\n 0 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded down.\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_setHpLevel(channel: ::std::os::raw::c_int, decibels: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DEPRECATED\n Equivalent to Bela_setHpLevel(-1, decibels);"]
    pub fn Bela_setHeadphoneLevel(decibels: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Mute or unmute the onboard speaker amplifiers.\n\n This function mutes or unmutes the amplifiers on the Bela cape. Whether the speakers begin\n muted or unmuted depends on the BelaInitSettings structure passed to Bela_initAudio().\n\n \\b Important: do not call this function from within render(), as it does not make\n any guarantees on real-time performance.\n\n \\param mute 0 to enable the speakers, nonzero to mute the speakers.\n\n \\return 0 on success, or nonzero if an error occurred."]
    pub fn Bela_muteSpeakers(mute: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a new auxiliary task.\n\n This function creates a new auxiliary task which, when scheduled, runs the function specified\n in the first argument. Note that the task does not run until scheduleAuxiliaryTask() is called.\n Auxiliary tasks should be created in `setup()` and never in `render()` itself.\n\n The second argument specifies the real-time priority. Valid values are between 0\n and 99, and usually should be lower than \\ref BELA_AUDIO_PRIORITY. Tasks with higher priority always\n preempt tasks with lower priority.\n\n \\param callback Function which will be called each time the auxiliary task is scheduled, unless it is already running.\n \\param priority Xenomai priority level at which the task should run.\n \\param name Name for this task, which should be unique system-wide (no other running program should use this name).\n \\param arg The argument passed to the callback function."]
    pub fn Bela_createAuxiliaryTask(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        priority: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> AuxiliaryTask;
}
extern "C" {
    #[doc = " \\brief Run an auxiliary task which has previously been created.\n\n This function will schedule an auxiliary task to run.\n\n If the task is already running, calling this function has no effect.\n If the task is not running (e.g.: a previous invocation has returned), the \\b callback function defined\n in Bela_createAuxiliaryTask() will be called and it will be passed the \\b arg pointer as its only parameter.\n\n This function is typically called from render() to start a lower-priority task. The function\n will not run immediately, but only once any active higher priority tasks have finished.\n\n \\param task Task to schedule for running.\n \\return 0 if the task was successfully scheduled, a positive error number otherwise. The most frequent error will be EBUSY, if the task was still running as a consequence of a previous call."]
    pub fn Bela_scheduleAuxiliaryTask(task: AuxiliaryTask) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize an auxiliary task so that it can be scheduled.\n\n User normally do not need to call this function.\n\n This function will start an auxiliary task but will NOT schedule it.\n This means that the callback function associated with the task will NOT be executed.\n\n It will also set a flag in the associate InternalAuxiliaryTask to flag the\n task as \"started\", so that successive calls to the same function for a given AuxiliaryTask\n have no effect.\n The user should never be required to call this function directly, as it is called\n by Bela_scheduleAuxiliaryTask if needed (e.g.: if a task is scheduled in setup() )\n or immediately after starting the audio thread.\n\n \\param task Task to start."]
    pub fn Bela_startAuxiliaryTask(task: AuxiliaryTask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Bela_startAllAuxiliaryTasks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Bela_stopAllAuxiliaryTasks();
}
extern "C" {
    pub fn Bela_deleteAllAuxiliaryTasks();
}
